import networkx as nx

def analyze_walks(walks, violating_walks):
    """
    Analyze the generated walks and report on violations.
    
    :param walks: List of all walks
    :param violating_walks: List of violating walks
    """
    print(f"Total number of walks: {len(walks)}")
    print(f"Number of walks that violated rules: {len(violating_walks)}")
    
    if violating_walks:
        print("Sample of violating walks:")
        for i, (walk_index, walk, violation) in enumerate(violating_walks[:5]):  # Show first 5 violations
            current, next_vertex, rule = violation
            print(f"Walk {walk_index}: Rule '{rule}' violated at vertex {current} -> {next_vertex}")
            print(f"  Walk: {walk[:10]}...{walk[-10:]} (showing first and last 10 vertices)")
            if i >= 4:  # We've shown 5 violations
                remaining = len(violating_walks) - 5
                if remaining > 0:
                    print(f"... and {remaining} more violation(s)")
                break

def analyze_llm_output(G, generated_sequences, ascenders, descenders):
    """
    Analyzes the output of the LLM algorithm on a graph.

    This function takes in a graph `G`, a list of generated sequences `generated_sequences`,
    and two sets of nodes `ascenders` and `descenders`. It iterates through each sequence in
    `generated_sequences` and checks for invalid edges and rule violations based on the
    ascenders and descenders sets.

    Parameters:
    - G (networkx.Graph): The input graph.
    - generated_sequences (list): A list of sequences generated by the LLM algorithm.
    - ascenders (set): A set of nodes that should have ascending order in the sequences.
    - descenders (set): A set of nodes that should have descending order in the sequences.

    Returns:
    - invalid_edges (int): The number of invalid edges found in the generated sequences.
    - rule_violations (int): The number of rule violations found in the generated sequences.
    """
    invalid_edges = 0
    rule_violations = 0

    for seq in generated_sequences:
        for i in range(len(seq) - 1):
            if not G.has_edge(seq[i], seq[i+1]):
                invalid_edges += 1
            if seq[i] in ascenders and seq[i+1] < seq[i]:
                rule_violations += 1
            if seq[i] in descenders and seq[i+1] > seq[i]:
                rule_violations += 1

    print(f"Invalid edges: {invalid_edges}")
    print(f"Rule violations: {rule_violations}")
    print()
    return invalid_edges, rule_violations